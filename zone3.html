<!DOCTYPE html>

<html lang="fr">

<head>

    <meta charset="UTF-8">

    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>Zone 3 : C'est la merde</title>



<style>

@import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');



body {

    /* MODIFICATION 1: Correction du fond pour qu'il remplisse bien l'écran */

    background-image: url('https://neocardmaker.com/uploads/monthly_2019_10/1502293590_Spooky2.gif.aa0118140c56d49b8ecc4294d9e4bd34.gif');

    background-size: cover;

    background-repeat: no-repeat;

@@ -107,6 +106,23 @@

    pointer-events: none;

    z-index: 5000;

}



/* NOUVEAU: Style du bouton final */

#final-button {

    position: fixed;

    top: 50%;

    left: 50%;

    transform: translate(-50%, -50%);

    padding: 15px 30px;

    font-size: 1em;

    background: black;

    color: white;

    border: 3px solid white;

    cursor: pointer;

    z-index: 6000;

    display: none;

    transition: opacity 0.5s;

}

</style>

</head>



@@ -129,6 +145,8 @@

<img id="img5" class="scene-img" src="https://i.imgur.com/oBwbwxW.png">

<img id="img6" class="scene-img" src="https://i.imgur.com/kuEm3Fv.png">



<button id="final-button" onclick="window.location.href='fin.html'">Dormir</button>



<script>

/* ---------------------- TEXT ENGINE ---------------------- */



@@ -146,7 +164,6 @@

typeSound.volume = 0.5;

typeSoundThought.volume = 0.5;



// Fonction pour arrêter le son

function stopSound(soundEl) {

    soundEl.pause();

    soundEl.currentTime = 0;

@@ -159,6 +176,9 @@

    tBox.removeEventListener('click', next);

    dBox.onclick = null;

    tBox.onclick = null;

    

    // Cache le bouton final si jamais il était là

    document.getElementById("final-button").style.display = "none";



    span.innerHTML = "";

    box.style.display = "block";

@@ -170,13 +190,10 @@



    span.classList.add("cursor-active");



    // NOUVEAU: Gestion du son pour le narrateur (long) vs la pensée (court)

    if (isLongSound) {

        // Pour le narrateur (long son de 6 min), on le lance une seule fois au début

        sound.currentTime = 0;

        sound.play().catch(()=>{});

    } else {

        // Pour la pensée, on le joue en boucle pendant la frappe

        if(sound.paused) {

            sound.currentTime = 0;

            sound.play().catch(()=>{});

@@ -191,15 +208,12 @@

        } else if (i < text.length) {

            span.innerHTML += text[i++];



            // Si c'est le narrateur (son long), on coupe le son s'il n'y a plus de lettres.

            // S'il ne reste qu'une seule lettre à afficher après celle-ci, on peut couper le son.

            if (isLongSound && i >= text.length - 1) {

                stopSound(sound);

            }

        } else end();

    }, 28);



    // NOUVEAU: Écouteur pour skipper le texte au clic sur la boîte

    box.onclick = (e) => {

        if (isTyping) {

            skipTyping = true;

@@ -211,25 +225,17 @@

        clearInterval(interval);

        span.classList.remove("cursor-active");



        // On s'assure que le son est coupé, surtout si c'est la pensée (son court)

        if (!isLongSound) {

            stopSound(sound);

        }



        isTyping = false;

        // Une fois terminé, le clic sur la boîte sert à avancer la séquence

        box.onclick = next;

    }

}



function showDialogue(t) { 

    // Le narrateur est un "long son" (true)

    typeWriter(t, dBox, dText, typeSound, true); 

}

function showThought(t) { 

    // La pensée est un "court son" (false)

    typeWriter(t, tBox, tText, typeSoundThought, false); 

}

function showDialogue(t) { typeWriter(t, dBox, dText, typeSound, true); }

function showThought(t) { typeWriter(t, tBox, tText, typeSoundThought, false); }



/* ---------------------- SCENE IMAGES ---------------------- */



@@ -238,14 +244,12 @@

    currentImageShown = null;

}



// NOUVEAU: Fonction appelée au clic n'importe où pour masquer l'image

function hideImageAndContinue(e) {

    if (currentImageShown) {

        hideAllImages();

        // On enlève l'écouteur général du body pour cacher l'image

        document.body.removeEventListener('click', hideImageAndContinue, true);

        next(); // On passe à l'étape suivante

        e.stopPropagation(); // Évite que le clic n'appelle next() une seconde fois

        next();

        e.stopPropagation();

    }

}



@@ -259,11 +263,9 @@

    imgElement.style.display = "block";

    currentImageShown = imgElement;



    // NOUVEAU: Le clic n'importe où sur l'écran (le body) fait disparaître l'image

    document.body.addEventListener('click', hideImageAndContinue, {once: true, capture: true}); 

}



// Fonction pour changer le fond (point 3)

function changeBackground(url) {

    document.body.style.backgroundImage = `url('${url}')`;

    next();

@@ -272,26 +274,107 @@



/* ---------------------- GLITCH ---------------------- */



// NOUVEAU: Tableau pour stocker les positions déjà utilisées

let usedPositions = [];

// Dimensions d'un gif (approx. 180px)

const GIF_SIZE = 180; 



function getRandomGlitchPosition(existingGifsCount) {

    // Calculer le nombre de colonnes et de lignes pour une grille de base

    const cols = Math.floor(window.innerWidth / GIF_SIZE) - 1;

    const rows = Math.floor(window.innerHeight / GIF_SIZE) - 1;

    const maxSlots = cols * rows;



    if (existingGifsCount >= maxSlots) return null; // Plus de place



    let x, y, positionKey;

    let attempts = 0;

    

    do {

        // Sélection d'une position de grille

        const col = Math.floor(Math.random() * cols);

        const row = Math.floor(Math.random() * rows);



        // Conversion en coordonnées px

        x = col * GIF_SIZE + (Math.random() * 50);

        y = row * GIF_SIZE + (Math.random() * 50);



        positionKey = `${col}-${row}`;

        attempts++;

        if (attempts > 100) return null; // Sécurité si ça boucle trop

    } while (usedPositions.includes(positionKey));



    usedPositions.push(positionKey);

    return {x, y};

}



function spawnGlitch(amount) {

    amount *= 5;

    for (let i = 0; i < amount; i++) {

    // Si c'est la première fois, on réinitialise les positions

    if (document.querySelectorAll(".glitch-gif").length === 0) {

        usedPositions = [];

    }

    

    // On garde un max raisonnable pour le temps de calcul

    const MAX_GIFS = 30; 

    let currentCount = document.querySelectorAll(".glitch-gif").length;

    let actualAmount = Math.min(amount, MAX_GIFS - currentCount);



    for (let i = 0; i < actualAmount; i++) {

        const pos = getRandomGlitchPosition(currentCount + i);

        if (!pos) break;



        const g = document.createElement("img");

        g.src = "https://i.imgur.com/UsrQHo8.gif";

        g.className = "glitch-gif";

        g.style.top = Math.random()*90+"vh";

        g.style.left = Math.random()*90+"vw";

        g.style.top = pos.y + "px";

        g.style.left = pos.x + "px";

        document.body.appendChild(g);

    }

    next(); 

    next();

}



function removeGlitch(percent) {

    const gifs = [...document.querySelectorAll(".glitch-gif")];

    const count = Math.floor(gifs.length * percent);

    for (let i = 0; i < count; i++) gifs[i].remove();

    // MODIFICATION: On cible tous les gifs, puis on sélectionne ceux à retirer

    let gifs = [...document.querySelectorAll(".glitch-gif")];

    

    // NOUVEAU: Si percent est 1, on retire TOUS les gifs et on vide les positions.

    if (percent >= 1) {

        gifs.forEach(g => g.remove());

        usedPositions = [];

    } else {

        const countToRemove = Math.floor(gifs.length * percent);

        

        // Pour s'assurer qu'on retire une bonne dispersion, on les mélange

        gifs.sort(() => Math.random() - 0.5); 

        

        for (let i = 0; i < countToRemove; i++) {

            if (gifs[i]) {

                // On pourrait rendre la suppression plus propre en retirant les positions, 

                // mais pour la simplicité et la nature temporaire, on se concentre sur l'élément DOM.

                gifs[i].remove();

            }

        }

    }

    next(); 

}



/* ---------------------- FONCTION FINALE ---------------------- */



function createButton() {

    // Enlève l'écouteur du body

    document.body.removeEventListener('click', next);

    

    // Affiche le bouton

    const button = document.getElementById("final-button");

    button.style.opacity = 0;

    button.style.display = "block";

    

    // Fondu d'apparition

    setTimeout(() => {

        button.style.opacity = 1;

    }, 50);

}



/* ---------------------- SEQUENCE ---------------------- */



const seq = [

@@ -301,7 +384,7 @@

    ()=>showThought("Et encourageant en plus !"),

    ()=>showDialogue("Alice avais beau se cacher sous sous sarcasme, elle était terrorisé"),



    ()=>spawnGlitch(6),

    ()=>spawnGlitch(6), // Première vague



    ()=>showDialogue("Et elle avais raison d'avoir aussi peur, car elle savais très bien qu'un jour ça finirais par se produite"),

    ()=>showThought("Euh, quoi ?"),

@@ -310,7 +393,7 @@

    ()=>showDialogue("Ta vie est fini, abandonne, arrête d'essayer d'être heureuse, c'est vain."),

    ()=>showThought("Oui, je sais."),



    ()=>spawnGlitch(10),

    ()=>spawnGlitch(10), // Deuxième vague (comble les trous)



    ()=>showThought("Je commence à me sentir mal là, arrête."),

    ()=>showDialogue("Alice savais que je ne fessai que dire la vérité mais continuais de nier"),

@@ -327,23 +410,22 @@



    ()=>showImage("img4"),



    ()=>removeGlitch(0.4),

    ()=>removeGlitch(0.4), // Retire 40% de TOUS les glitches actifs



    ()=>showThought("Belle formulation j'avoue, t'es doué."),

    ()=>showThought("Mais ça ne changera pas le fait que je suis qu'une merde."),



    // NOUVEAU: Changement du fond avec la bonne URL

    ()=>changeBackground('https://c.tenor.com/ZL7fgNaWWXMAAAAd/tenor.gif'),



    ()=>showImage("img5"),



    ()=>removeGlitch(0.7),

    ()=>removeGlitch(0.7), // Retire 70% de ceux qui restent



    ()=>showThought("Merci beaucoup, je sais pas ce que je ferais sans toi"),



    ()=>showImage("img6"),



    ()=>removeGlitch(1),

    ()=>removeGlitch(1), // Retire 100% de ceux qui restent



    ()=>fadeToEnd

];

@@ -361,33 +443,30 @@

/* ---------------------- FIN ---------------------- */



function fadeToEnd() {

    // La dernière image devrait être cachée par hideImageAndContinue, 

    // mais on le fait une dernière fois pour être sûr.

    hideAllImages(); 



    // On s'assure qu'il n'y a plus d'écouteurs actifs sur le body

    

    // On s'assure qu'il n'y a plus d'écouteurs d'images/boîtes actifs

    document.body.removeEventListener('click', hideImageAndContinue, true);

    dBox.onclick = null;

    tBox.onclick = null;

    document.body.removeEventListener('click', next);



    const black = document.getElementById("fade-black");

    black.style.opacity = 1;



    setTimeout(()=>{

        // Laisse le fond noir 1.2s, puis :

        black.style.opacity = 0; 



        // Correction 4: Redirection vers fin.html

        window.location.href="fin.html"; 

    }, 1200); // Laisse le temps pour le fondu noir

        // NOUVEAU: Affiche le bouton "Dormir" pour la redirection manuelle

        setTimeout(createButton, 100); 

    }, 1200);

}



// L'écouteur initial est changé pour lancer la séquence au clic, 

// puis on ajoute un écouteur général sur le body pour l'avancement.

document.getElementById("intro-overlay-zone2").onclick = () => {

    document.getElementById("intro-overlay-zone2").style.display = "none";

    // Après que l'overlay ait disparu, le premier clic lance la séquence (qui commence par showThought)

    // On ajoute un écouteur général pour gérer l'avancement des étapes qui n'ont pas de boîte de dialogue/pensée (ex: glitch)

    document.body.addEventListener('click', next);

    // On lance la première action tout de suite

    next(); 

};

</script>
